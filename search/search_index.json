{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenido Esta es la documentaci\u00f3n del servidor de Buscamed Venezuela . Este programa est\u00e1 configurado para funcionar en Heroku , pero puede ser utilizado localmente con las siguientes instrucciones. Autores: Lautaro Villal\u00f3n, 12-10427 Yarima Luciani, 13-10770 Instalaci\u00f3n Configuracion de la BD: $ sudo apt-get update $ sudo apt-get install python3-pip python3-dev libpq-dev postgresql postgresql-contrib $ sudo -u postgres psql postgres=# CREATE DATABASE buscamedserver; postgres=# CREATE USER buscameduser WITH PASSWORD [contrase\u00f1a]; postgres=# ALTER ROLE buscameduser SET client_encoding TO 'utf8'; postgres=# ALTER ROLE buscameduser SET default_transaction_isolation TO 'read committed'; postgres=# ALTER ROLE buscameduser SET timezone TO 'UTC'; postgres=# GRANT ALL PRIVILEGES ON DATABASE buscamedserver TO buscameduser; postgres=# \\q $ sudo ufw allow 8000 Primera Corrida: Nota: Es recomendable usar un virtual environment Nota 2: Deber\u00e1 agregar las variables de sistema: TWITTER_AUTH y DB_PASSWORD $ pip install -r requirements.txt $ python manage.py makemigrations $ python manage.py migrate $ python manage.py createsuperuser (user: admin, email: admin@admin.com) $ python manage.py loadmeds data/baseDatos-completa.csv $ python manage.py runserver 0.0.0.0:8000 Escribir en un browser 127.0.0.1:8000 Funcionamiento general Incluye un API rest con varios accesos para obtener datos de medicinas en Venezuela: /rest/tweets?med=[medicina] /rest/web/?med=[medicina] /rest/stores/?med=[medicina] Incluye un homepage que hace uso del API rest para mostrar los datos Inlcuye una aplicaci\u00f3n de acceso a usuarios de farmacias para que puedan enviar sus inventarios en formato .CSV /stores/login /stores/readFile","title":"Inicio"},{"location":"#bienvenido","text":"Esta es la documentaci\u00f3n del servidor de Buscamed Venezuela . Este programa est\u00e1 configurado para funcionar en Heroku , pero puede ser utilizado localmente con las siguientes instrucciones.","title":"Bienvenido"},{"location":"#autores","text":"Lautaro Villal\u00f3n, 12-10427 Yarima Luciani, 13-10770","title":"Autores:"},{"location":"#instalacion","text":"","title":"Instalaci\u00f3n"},{"location":"#configuracion-de-la-bd","text":"$ sudo apt-get update $ sudo apt-get install python3-pip python3-dev libpq-dev postgresql postgresql-contrib $ sudo -u postgres psql postgres=# CREATE DATABASE buscamedserver; postgres=# CREATE USER buscameduser WITH PASSWORD [contrase\u00f1a]; postgres=# ALTER ROLE buscameduser SET client_encoding TO 'utf8'; postgres=# ALTER ROLE buscameduser SET default_transaction_isolation TO 'read committed'; postgres=# ALTER ROLE buscameduser SET timezone TO 'UTC'; postgres=# GRANT ALL PRIVILEGES ON DATABASE buscamedserver TO buscameduser; postgres=# \\q $ sudo ufw allow 8000","title":"Configuracion de la BD:"},{"location":"#primera-corrida","text":"Nota: Es recomendable usar un virtual environment Nota 2: Deber\u00e1 agregar las variables de sistema: TWITTER_AUTH y DB_PASSWORD $ pip install -r requirements.txt $ python manage.py makemigrations $ python manage.py migrate $ python manage.py createsuperuser (user: admin, email: admin@admin.com) $ python manage.py loadmeds data/baseDatos-completa.csv $ python manage.py runserver 0.0.0.0:8000 Escribir en un browser 127.0.0.1:8000","title":"Primera Corrida:"},{"location":"#funcionamiento-general","text":"Incluye un API rest con varios accesos para obtener datos de medicinas en Venezuela: /rest/tweets?med=[medicina] /rest/web/?med=[medicina] /rest/stores/?med=[medicina] Incluye un homepage que hace uso del API rest para mostrar los datos Inlcuye una aplicaci\u00f3n de acceso a usuarios de farmacias para que puedan enviar sus inventarios en formato .CSV /stores/login /stores/readFile","title":"Funcionamiento general"},{"location":"about/","text":"About Proyecto realizado en la Universidad Sim\u00f3n Bol\u00edvar para la materia Miniproyecto de Desarrollo de Software (EP4793) del trimestre Sep-Dic 2018 . Este proyecto fue desarrollado con fines acad\u00e9micos por: Lautaro Villal\u00f3n - 12-10427 Yarima Luciani - 13-10770 Basado en el Miniproyecto de Abr-Jul 2017 por: Antonio Cipagauta - 05-38040 Douglas Torres - 11-11027 Ambos con la tutor\u00eda de: Prof. Ivette Carolina Mart\u00ednez Actualmente el proyecto se encuentra publicado en buscamed.org.ve . Para mayor informaci\u00f3n, cont\u00e1ctenos a trav\u00e9s de: buscamedvzla@gmail.com","title":"About"},{"location":"about/#about","text":"Proyecto realizado en la Universidad Sim\u00f3n Bol\u00edvar para la materia Miniproyecto de Desarrollo de Software (EP4793) del trimestre Sep-Dic 2018 . Este proyecto fue desarrollado con fines acad\u00e9micos por: Lautaro Villal\u00f3n - 12-10427 Yarima Luciani - 13-10770 Basado en el Miniproyecto de Abr-Jul 2017 por: Antonio Cipagauta - 05-38040 Douglas Torres - 11-11027 Ambos con la tutor\u00eda de: Prof. Ivette Carolina Mart\u00ednez Actualmente el proyecto se encuentra publicado en buscamed.org.ve . Para mayor informaci\u00f3n, cont\u00e1ctenos a trav\u00e9s de: buscamedvzla@gmail.com","title":"About"},{"location":"bibliografia/","text":"Bibliograf\u00eda Herramientas utilizadas Python 3.6.6 BeautifulSoup(4.6.3) Django(2.1.2) django-cors-headers(2.4.0) Django-Heroku(0.3.1) Django Rest Framework(3.8.2) Gunicorn(19.9.0) NLTK(3.3) NumPy(1.13.0) Pandas(0.23.4) Psycopg2(2.7.5) Python Twitter(3.5) Scikit Learn(0.18.2) SciPy(1.1.0) Tweepy(3.6.0) JavaScript jQuery(3.3.1) jQuery-CSV(0.8.9) HTML & CSS Bootstrap(4.1.3) Font Awesome(5.3.1) Simple-Line-Icons(2.4.0) Dropify(0.2.0)","title":"Bibliografia"},{"location":"bibliografia/#bibliografia","text":"","title":"Bibliograf\u00eda"},{"location":"bibliografia/#herramientas-utilizadas","text":"","title":"Herramientas utilizadas"},{"location":"bibliografia/#python-366","text":"BeautifulSoup(4.6.3) Django(2.1.2) django-cors-headers(2.4.0) Django-Heroku(0.3.1) Django Rest Framework(3.8.2) Gunicorn(19.9.0) NLTK(3.3) NumPy(1.13.0) Pandas(0.23.4) Psycopg2(2.7.5) Python Twitter(3.5) Scikit Learn(0.18.2) SciPy(1.1.0) Tweepy(3.6.0)","title":"Python 3.6.6"},{"location":"bibliografia/#javascript","text":"jQuery(3.3.1) jQuery-CSV(0.8.9)","title":"JavaScript"},{"location":"bibliografia/#html-css","text":"Bootstrap(4.1.3) Font Awesome(5.3.1) Simple-Line-Icons(2.4.0) Dropify(0.2.0)","title":"HTML &amp; CSS"},{"location":"buscaMedServer/buscaMedServer/","text":"M\u00f3dulo: buscaMedServer En este m\u00f3dulo se encuentra definida la configuraci\u00f3n general del projecto de Django . settings.py En este archivo se encuentran definidas las variables globales y las configuraciones generales del proyecto. Vale la pena destacar las siguientes: DEBUG: Variable que permite hacer uso de la aplicaci\u00f3n mientras de desarrolla. ALLOWED_HOSTS: Arreglo donde se definen las direcciones donde puede correr la aplicaci\u00f3n. INSTALLED_APPS: Arreglo donde se definen las librerias y modulos de la aplicaci\u00f3n. DATABASES: Configuraci\u00f3n general de la base de datos asociada a la aplicaci\u00f3n. REST_FRAMEWORK: Configuraci\u00f3n del API Rest (paginaci\u00f3n, autenticaci\u00f3n de acceso) LOGIN_REDIRECT_URL: URL donde se redirige una vez iniciada sesi\u00f3n. LOGOUT_REDIRECT_URL: URL donde se redirige una vez cerrada sesi\u00f3n. django_heroku.settings(locals()): Funci\u00f3n que configura autom\u00e1ticamente las configuaraciones en Heroku (Incluida la BD) TWITTER_AUTH: Variable donde se guardan las API keys de Twitter a utilizar. Lleva el siguiente formato: [{\"consumer_key\": \"xxxx\", \"consumer_secret\": \"xxxx\", \"access_token\": \"xxxx\", \"access_secret\": \"xxxx\"}] TWEET_UPDATE: Variable que define los minutos que deben pasar a partir de la b\u00fasqueda de un medicamento para volver a buscarlo en Twitter. Es decir, si pasan menos minutos para volver a buscar un mismo medicamento, muestra los tweets de la BD. Si pasan m\u00e1s minutos, vuelve a buscarlo en Twitter. TWEET_EXPIRATION: Variable que define los d\u00edas que deben pasar para que un Tweet sea considerado \"Expirado\" y al llamar al comando expireTweets se elimine. STORE_EXPIRATION Variable que define los d\u00edas que deben pasar para que el inventario de una tienda adscrita sea considerado \"Expirado\" y al llamar al comando expireStoreInventory se elimine. urls.py En este archivo est\u00e1n definidas todas las urls de la aplicaci\u00f3n. Para esto, importa todos los archivos urls.py de cada m\u00f3dulo. Para esto define una variable urlpatterns con la siguiente estructura: urlpatterns = [ path('', HomeView.as_view(), name='home'), # URL DEL HOMEPAGE url(r'^rest/', include('rest.urls')), # URLS DEL API REST url(r'^stores/', include('stores.urls')), # URLS DE LA APP DE TIENDAS url(r'admin/', admin.site.urls), # URLS ADMINISTRATIVAS ]","title":"BuscaMedServer"},{"location":"buscaMedServer/buscaMedServer/#modulo-buscamedserver","text":"En este m\u00f3dulo se encuentra definida la configuraci\u00f3n general del projecto de Django .","title":"M\u00f3dulo: buscaMedServer"},{"location":"buscaMedServer/buscaMedServer/#settingspy","text":"En este archivo se encuentran definidas las variables globales y las configuraciones generales del proyecto. Vale la pena destacar las siguientes: DEBUG: Variable que permite hacer uso de la aplicaci\u00f3n mientras de desarrolla. ALLOWED_HOSTS: Arreglo donde se definen las direcciones donde puede correr la aplicaci\u00f3n. INSTALLED_APPS: Arreglo donde se definen las librerias y modulos de la aplicaci\u00f3n. DATABASES: Configuraci\u00f3n general de la base de datos asociada a la aplicaci\u00f3n. REST_FRAMEWORK: Configuraci\u00f3n del API Rest (paginaci\u00f3n, autenticaci\u00f3n de acceso) LOGIN_REDIRECT_URL: URL donde se redirige una vez iniciada sesi\u00f3n. LOGOUT_REDIRECT_URL: URL donde se redirige una vez cerrada sesi\u00f3n. django_heroku.settings(locals()): Funci\u00f3n que configura autom\u00e1ticamente las configuaraciones en Heroku (Incluida la BD) TWITTER_AUTH: Variable donde se guardan las API keys de Twitter a utilizar. Lleva el siguiente formato: [{\"consumer_key\": \"xxxx\", \"consumer_secret\": \"xxxx\", \"access_token\": \"xxxx\", \"access_secret\": \"xxxx\"}] TWEET_UPDATE: Variable que define los minutos que deben pasar a partir de la b\u00fasqueda de un medicamento para volver a buscarlo en Twitter. Es decir, si pasan menos minutos para volver a buscar un mismo medicamento, muestra los tweets de la BD. Si pasan m\u00e1s minutos, vuelve a buscarlo en Twitter. TWEET_EXPIRATION: Variable que define los d\u00edas que deben pasar para que un Tweet sea considerado \"Expirado\" y al llamar al comando expireTweets se elimine. STORE_EXPIRATION Variable que define los d\u00edas que deben pasar para que el inventario de una tienda adscrita sea considerado \"Expirado\" y al llamar al comando expireStoreInventory se elimine.","title":"settings.py"},{"location":"buscaMedServer/buscaMedServer/#urlspy","text":"En este archivo est\u00e1n definidas todas las urls de la aplicaci\u00f3n. Para esto, importa todos los archivos urls.py de cada m\u00f3dulo. Para esto define una variable urlpatterns con la siguiente estructura: urlpatterns = [ path('', HomeView.as_view(), name='home'), # URL DEL HOMEPAGE url(r'^rest/', include('rest.urls')), # URLS DEL API REST url(r'^stores/', include('stores.urls')), # URLS DE LA APP DE TIENDAS url(r'admin/', admin.site.urls), # URLS ADMINISTRATIVAS ]","title":"urls.py"},{"location":"classifier/classifier/","text":"M\u00f3dulo: classifier En este m\u00f3dulo se encuentran los programas de clasificaci\u00f3n y entrenamiento de la m\u00e1quina clasificadora de tweets. Esta m\u00e1quina clasifica tweets en oferta , demanda y ninguno . Para usos del BuscaMed Server , solo guardamos los tweets clasificados como oferta . classifier.py Autores Version 1.0: Antonio Cipagauta, 05-38040 | Douglas Torres, 11-11027 Version 2.0: Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Version 2.1: Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Archivo donde se encuentran tres versiones del clasificador, separadas por comentarios (esto para mantener la retro-compatibilidad y para adoptar, sin cambios, varias cosas de la primera versi\u00f3n en las otras). Este clasificador hace uso de Tweepy para acceder al API de Twitter y realizar las b\u00fasquedas de medicinas, para luego clasificar los tweets y guardarlos en la BD. Versi\u00f3n 1.0 Clase Tweet: Utilizada para facilitar la manipulaci\u00f3n de los datos obtenidos del API de Twitter class Tweet: def __init__(self, url, text, medicines): self.url = url self.text = text self.medicines = medicines def set_cluster(self, cluster): def get_id(self): tweepy_auth: Devuelve un objeto api de Tweepy que permite realizar las b\u00fasquedas a Twitter . Recibe un diccionario con el siguiente formato: keys = [{\"consumer_key\": \"xxxx\", \"consumer_secret\": \"xxxx\", \"access_token\": \"xxxx\", \"access_secret\": \"xxxx\"}] def tweepy_auth(keys) -> tweepy.api clean: Devuelve un objeto Tweet a partir de un tweet crudo obtenido por el API de Twitter . def clean(tweet): -> Tweet classify: Devuelve un objeto Tweet ya clasificado en oferta o demanda , a partir de un tweet crudo obtenido por el API de Twitter . def classify(raw_tweet): -> Tweet batchClassify: Busca todas las medicinas conocidas (guardadas en la variable medicines_list ) en Twitter , clasifica los tweets y los guarda en la BD. def batchClassify(): -> None Versi\u00f3n 2.0 listarTweets: Busca una lista de medicinas dada en Twitter , clasifica los tweets y los guarda en la BD. Opcional: recibe un id de un tweet para buscar solamente tweets m\u00e1s recientes. def listarTweets(medicine_list, from_id=None): -> None Versi\u00f3n 2.1 Clase ListarThread: Utilizada para generar hilos que busquen listas de medicinas concurrentemente en Twitter con diferentes API keys. ListarThread.run() es equivalente a listarTweets() . class ListarThread(threading.Thread): def __init__(self, keys, medicine_list, from_id): threading.Thread.__init__(self) self.keys = keys self.medicine_list = medicine_list self.from_id = from_id def run(self): threadingTweets: Funci\u00f3n que recibe una lista de API keys y una lista de medicinas, divide la lista de medicinas entre todas las API keys y crea hilos de ListarThread . Cada hilo tiene una API key y una sublista de medicinas, de esta manera se distribuye la carga de b\u00fasqueda entre las API keys. Opcional: recibe un id de un tweet para buscar solamente tweets m\u00e1s recientes. def threadingTweets(keys, medicine_list, from_id=None): -> None train.py Autores Version 1.0: Antonio Cipagauta, 05-38040 | Douglas Torres, 11-11027 Descripci\u00f3n Archivo que contiene el programa principal que se encarga de entrenar el modelo utilizado por el clasificador de tweets. Los datos de todas las posibles medicinas los obtiene de: ../data/baseDatos-completa.csv Los datos clasificados para entrenar los obtiene de: ../data/tweetsClasificados-3000.csv","title":"Classifier"},{"location":"classifier/classifier/#modulo-classifier","text":"En este m\u00f3dulo se encuentran los programas de clasificaci\u00f3n y entrenamiento de la m\u00e1quina clasificadora de tweets. Esta m\u00e1quina clasifica tweets en oferta , demanda y ninguno . Para usos del BuscaMed Server , solo guardamos los tweets clasificados como oferta .","title":"M\u00f3dulo: classifier"},{"location":"classifier/classifier/#classifierpy","text":"Autores Version 1.0: Antonio Cipagauta, 05-38040 | Douglas Torres, 11-11027 Version 2.0: Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Version 2.1: Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Archivo donde se encuentran tres versiones del clasificador, separadas por comentarios (esto para mantener la retro-compatibilidad y para adoptar, sin cambios, varias cosas de la primera versi\u00f3n en las otras). Este clasificador hace uso de Tweepy para acceder al API de Twitter y realizar las b\u00fasquedas de medicinas, para luego clasificar los tweets y guardarlos en la BD.","title":"classifier.py"},{"location":"classifier/classifier/#version-10","text":"","title":"Versi\u00f3n 1.0"},{"location":"classifier/classifier/#clase-tweet","text":"Utilizada para facilitar la manipulaci\u00f3n de los datos obtenidos del API de Twitter class Tweet: def __init__(self, url, text, medicines): self.url = url self.text = text self.medicines = medicines def set_cluster(self, cluster): def get_id(self):","title":"Clase Tweet:"},{"location":"classifier/classifier/#tweepy_auth","text":"Devuelve un objeto api de Tweepy que permite realizar las b\u00fasquedas a Twitter . Recibe un diccionario con el siguiente formato: keys = [{\"consumer_key\": \"xxxx\", \"consumer_secret\": \"xxxx\", \"access_token\": \"xxxx\", \"access_secret\": \"xxxx\"}] def tweepy_auth(keys) -> tweepy.api","title":"tweepy_auth:"},{"location":"classifier/classifier/#clean","text":"Devuelve un objeto Tweet a partir de un tweet crudo obtenido por el API de Twitter . def clean(tweet): -> Tweet","title":"clean:"},{"location":"classifier/classifier/#classify","text":"Devuelve un objeto Tweet ya clasificado en oferta o demanda , a partir de un tweet crudo obtenido por el API de Twitter . def classify(raw_tweet): -> Tweet","title":"classify:"},{"location":"classifier/classifier/#batchclassify","text":"Busca todas las medicinas conocidas (guardadas en la variable medicines_list ) en Twitter , clasifica los tweets y los guarda en la BD. def batchClassify(): -> None","title":"batchClassify:"},{"location":"classifier/classifier/#version-20","text":"","title":"Versi\u00f3n 2.0"},{"location":"classifier/classifier/#listartweets","text":"Busca una lista de medicinas dada en Twitter , clasifica los tweets y los guarda en la BD. Opcional: recibe un id de un tweet para buscar solamente tweets m\u00e1s recientes. def listarTweets(medicine_list, from_id=None): -> None","title":"listarTweets:"},{"location":"classifier/classifier/#version-21","text":"","title":"Versi\u00f3n 2.1"},{"location":"classifier/classifier/#clase-listarthread","text":"Utilizada para generar hilos que busquen listas de medicinas concurrentemente en Twitter con diferentes API keys. ListarThread.run() es equivalente a listarTweets() . class ListarThread(threading.Thread): def __init__(self, keys, medicine_list, from_id): threading.Thread.__init__(self) self.keys = keys self.medicine_list = medicine_list self.from_id = from_id def run(self):","title":"Clase ListarThread:"},{"location":"classifier/classifier/#threadingtweets","text":"Funci\u00f3n que recibe una lista de API keys y una lista de medicinas, divide la lista de medicinas entre todas las API keys y crea hilos de ListarThread . Cada hilo tiene una API key y una sublista de medicinas, de esta manera se distribuye la carga de b\u00fasqueda entre las API keys. Opcional: recibe un id de un tweet para buscar solamente tweets m\u00e1s recientes. def threadingTweets(keys, medicine_list, from_id=None): -> None","title":"threadingTweets:"},{"location":"classifier/classifier/#trainpy","text":"Autores Version 1.0: Antonio Cipagauta, 05-38040 | Douglas Torres, 11-11027 Descripci\u00f3n Archivo que contiene el programa principal que se encarga de entrenar el modelo utilizado por el clasificador de tweets. Los datos de todas las posibles medicinas los obtiene de: ../data/baseDatos-completa.csv Los datos clasificados para entrenar los obtiene de: ../data/tweetsClasificados-3000.csv","title":"train.py"},{"location":"rest/commands/","text":"M\u00f3dulo: rest-commands En este m\u00f3dulo, ubicado en rest/management/commands, se encuentran los comandos personalizados de Django para gestionar los datos del servidor REST. Estos comandos pueden ser programados para gestionar autom\u00e1ticamente el servidor. batchClassification.py Autores Antonio Cipagauta, 05-38040 | Douglas Torres, 11-11027 Descripci\u00f3n Comando que llama a la funci\u00f3n del m\u00f3dulo classifier que busca todas las medicinas conocidas (guardadas en la variable medicines_list ) en Twitter , clasifica los tweets y los guarda en la BD. Uso: python manage.py batchClassification eraseTweets.py Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Comando que elimina todos los tweets de la BD. Uso: python manage.py eraseTweets expireTweets.py Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Comando que elimina los tweets que han llegado a su fecha de vencimiento. La variable del m\u00f3dulo de configuraci\u00f3n \"TWEET_EXPIRATION\" define cuantos d\u00edas tarda un tweet en expirar. Uso: python manage.py expireTweets loadmeds.py Autores Antonio Cipagauta, 05-38040 | Douglas Torres, 11-11027 Descripci\u00f3n Comando que carga la lista de medicinas y componentes activos a la BD. Recibe como argumento la direcci\u00f3n del archivo donde se encuentran las medicinas. Para Diciembre 2018 es: data/baseDatos-completa.csv. Uso: python manage.py loadmeds [archivo con lista de medicinas]","title":"management/commands"},{"location":"rest/commands/#modulo-rest-commands","text":"En este m\u00f3dulo, ubicado en rest/management/commands, se encuentran los comandos personalizados de Django para gestionar los datos del servidor REST. Estos comandos pueden ser programados para gestionar autom\u00e1ticamente el servidor.","title":"M\u00f3dulo: rest-commands"},{"location":"rest/commands/#batchclassificationpy","text":"Autores Antonio Cipagauta, 05-38040 | Douglas Torres, 11-11027 Descripci\u00f3n Comando que llama a la funci\u00f3n del m\u00f3dulo classifier que busca todas las medicinas conocidas (guardadas en la variable medicines_list ) en Twitter , clasifica los tweets y los guarda en la BD.","title":"batchClassification.py"},{"location":"rest/commands/#uso","text":"python manage.py batchClassification","title":"Uso:"},{"location":"rest/commands/#erasetweetspy","text":"Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Comando que elimina todos los tweets de la BD.","title":"eraseTweets.py"},{"location":"rest/commands/#uso_1","text":"python manage.py eraseTweets","title":"Uso:"},{"location":"rest/commands/#expiretweetspy","text":"Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Comando que elimina los tweets que han llegado a su fecha de vencimiento. La variable del m\u00f3dulo de configuraci\u00f3n \"TWEET_EXPIRATION\" define cuantos d\u00edas tarda un tweet en expirar.","title":"expireTweets.py"},{"location":"rest/commands/#uso_2","text":"python manage.py expireTweets","title":"Uso:"},{"location":"rest/commands/#loadmedspy","text":"Autores Antonio Cipagauta, 05-38040 | Douglas Torres, 11-11027 Descripci\u00f3n Comando que carga la lista de medicinas y componentes activos a la BD. Recibe como argumento la direcci\u00f3n del archivo donde se encuentran las medicinas. Para Diciembre 2018 es: data/baseDatos-completa.csv.","title":"loadmeds.py"},{"location":"rest/commands/#uso_3","text":"python manage.py loadmeds [archivo con lista de medicinas]","title":"Uso:"},{"location":"rest/models/","text":"M\u00f3dulo: rest-models En este m\u00f3dulo se encuentra definida la estructura de la base de datos en un modelo orientado a objetos utilizando el Django ORM original. Autores Version 1.0: Antonio Cipagauta, 05-38040 | Douglas Torres, 11-11027 Version 2.0: Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Clase Activo: Guarda cada componente activo sin repeticiones. class Activo(models.Model): componente = models.TextField(verbose_name=('Componente activo'),unique=True) Clase Medicina: Guarda cada medicina asociada a un componente activo. class Medicina(models.Model): nombre = models.TextField(verbose_name=('Nombre de marca')) activo = models.ForeignKey(Activo, related_name='componente-activo+', null=True, on_delete=models.CASCADE) Clase Presentacion: Guarda la presentaci\u00f3n y registro sanitario asociado a una medicina. Versi\u00f3n 2.0: Tabla sin utilizar por ser innecesaria hasta los momentos. Guardar las presentaciones ocupa m\u00e1s espacio del permitido por las limitaciones gratuitas de Heroku . Definida igualmente para expansi\u00f3n futura. class Presentacion(models.Model): presentacion = models.TextField(verbose_name=('Presentacion')) registro = models.TextField(verbose_name=('Registro sanitario')) medicina = models.ForeignKey(Medicina, related_name='formato',null=True, on_delete=models.CASCADE) Clase Tweet: Guarda cada tweet con su URL y tipo de clasificaci\u00f3n (Oferta/Demanda), asociado a una medicina. Versi\u00f3n 2.0: Guarda fecha de b\u00fasqueda de cada tweet para optimizar las b\u00fasquedas y calcular la expiraci\u00f3n. Define una funci\u00f3n que permite obtener el id de cada tweet a partir de su URL. class Tweet(models.Model): link = models.TextField(verbose_name=('Link'),unique=True) clasificacion = models.TextField(verbose_name=('Clasificacion')) medicina = models.ForeignKey(Medicina, related_name='Medicina', null=True, on_delete=models.CASCADE) fecha = models.DateTimeField(auto_now_add=True, blank=True) def getId(self): tweetId = self.link.split(\"/\")[-1] return int(tweetId)","title":"models.py"},{"location":"rest/models/#modulo-rest-models","text":"En este m\u00f3dulo se encuentra definida la estructura de la base de datos en un modelo orientado a objetos utilizando el Django ORM original. Autores Version 1.0: Antonio Cipagauta, 05-38040 | Douglas Torres, 11-11027 Version 2.0: Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770","title":"M\u00f3dulo: rest-models"},{"location":"rest/models/#clase-activo","text":"Guarda cada componente activo sin repeticiones. class Activo(models.Model): componente = models.TextField(verbose_name=('Componente activo'),unique=True)","title":"Clase Activo:"},{"location":"rest/models/#clase-medicina","text":"Guarda cada medicina asociada a un componente activo. class Medicina(models.Model): nombre = models.TextField(verbose_name=('Nombre de marca')) activo = models.ForeignKey(Activo, related_name='componente-activo+', null=True, on_delete=models.CASCADE)","title":"Clase Medicina:"},{"location":"rest/models/#clase-presentacion","text":"Guarda la presentaci\u00f3n y registro sanitario asociado a una medicina. Versi\u00f3n 2.0: Tabla sin utilizar por ser innecesaria hasta los momentos. Guardar las presentaciones ocupa m\u00e1s espacio del permitido por las limitaciones gratuitas de Heroku . Definida igualmente para expansi\u00f3n futura. class Presentacion(models.Model): presentacion = models.TextField(verbose_name=('Presentacion')) registro = models.TextField(verbose_name=('Registro sanitario')) medicina = models.ForeignKey(Medicina, related_name='formato',null=True, on_delete=models.CASCADE)","title":"Clase Presentacion:"},{"location":"rest/models/#clase-tweet","text":"Guarda cada tweet con su URL y tipo de clasificaci\u00f3n (Oferta/Demanda), asociado a una medicina. Versi\u00f3n 2.0: Guarda fecha de b\u00fasqueda de cada tweet para optimizar las b\u00fasquedas y calcular la expiraci\u00f3n. Define una funci\u00f3n que permite obtener el id de cada tweet a partir de su URL. class Tweet(models.Model): link = models.TextField(verbose_name=('Link'),unique=True) clasificacion = models.TextField(verbose_name=('Clasificacion')) medicina = models.ForeignKey(Medicina, related_name='Medicina', null=True, on_delete=models.CASCADE) fecha = models.DateTimeField(auto_now_add=True, blank=True) def getId(self): tweetId = self.link.split(\"/\")[-1] return int(tweetId)","title":"Clase Tweet:"},{"location":"rest/serializers/","text":"M\u00f3dulo: rest-serializers En este m\u00f3dulo se encuentran definidos los serializadores para convertir los objetos de la BD en objetos JSON. Utiliza el m\u00f3dulo serializers del Django Rest Framework . Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Clase ActivoSerializer: Define la estructura en JSON de un componente activo. Ejemplo: {'componente': Activo.componente}. class ActivoSerializer(serializers.ModelSerializer): class Meta: model = Activo fields = ('componente',) read_only_fields = ('componente',) Clase MedicinaSerializer: Define la estructura en JSON de una medicina. Ejemplo: {'nombre': Medicina.nombre, 'activo': {'componente': Activo.componente}}. N\u00f3tese que Medicina.activo se serializa con el serializador ActivoSerializer . class MedicinaSerializer(serializers.ModelSerializer): activo = ActivoSerializer() class Meta: model = Medicina fields = ('nombre', 'activo') read_only_fields = ('nombre', 'activo') Clase TweetSerializer: Define la estructura en JSON de un tweet. Ejemplo: {'id': Tweet.getId(), 'link': Tweet.link, 'medicina': {'nombre': Medicina.nombre, 'activo': {'componente': Activo.componente}}. N\u00f3tese que Tweet.medicina se serializa con el serializador MedicinaSerializer . class TweetSerializer(serializers.ModelSerializer): medicina = MedicinaSerializer() id = serializers.SerializerMethodField() class Meta: model = Tweet fields = ('id','link', 'medicina') read_only_fields = ('id','link', 'medicina') def get_id(self, obj): return obj.getId()","title":"serializers.py"},{"location":"rest/serializers/#modulo-rest-serializers","text":"En este m\u00f3dulo se encuentran definidos los serializadores para convertir los objetos de la BD en objetos JSON. Utiliza el m\u00f3dulo serializers del Django Rest Framework . Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770","title":"M\u00f3dulo: rest-serializers"},{"location":"rest/serializers/#clase-activoserializer","text":"Define la estructura en JSON de un componente activo. Ejemplo: {'componente': Activo.componente}. class ActivoSerializer(serializers.ModelSerializer): class Meta: model = Activo fields = ('componente',) read_only_fields = ('componente',)","title":"Clase ActivoSerializer:"},{"location":"rest/serializers/#clase-medicinaserializer","text":"Define la estructura en JSON de una medicina. Ejemplo: {'nombre': Medicina.nombre, 'activo': {'componente': Activo.componente}}. N\u00f3tese que Medicina.activo se serializa con el serializador ActivoSerializer . class MedicinaSerializer(serializers.ModelSerializer): activo = ActivoSerializer() class Meta: model = Medicina fields = ('nombre', 'activo') read_only_fields = ('nombre', 'activo')","title":"Clase MedicinaSerializer:"},{"location":"rest/serializers/#clase-tweetserializer","text":"Define la estructura en JSON de un tweet. Ejemplo: {'id': Tweet.getId(), 'link': Tweet.link, 'medicina': {'nombre': Medicina.nombre, 'activo': {'componente': Activo.componente}}. N\u00f3tese que Tweet.medicina se serializa con el serializador MedicinaSerializer . class TweetSerializer(serializers.ModelSerializer): medicina = MedicinaSerializer() id = serializers.SerializerMethodField() class Meta: model = Tweet fields = ('id','link', 'medicina') read_only_fields = ('id','link', 'medicina') def get_id(self, obj): return obj.getId()","title":"Clase TweetSerializer:"},{"location":"rest/urls/","text":"M\u00f3dulo: rest-urls En este m\u00f3dulo se encuentran definidas las URL para el acceso al m\u00f3dulo REST. Para esto se utiliza el m\u00f3dulo routers del Django Rest Framework . Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 router: Variable donde se registran las vistas del m\u00f3dulo rest-views . Esta variable es un objeto DefaultRouter del Django Rest Framework . router = routers.DefaultRouter() router.register(r'tweets', views.TweetViewSet) router.register(r'stores', views.StoresViewSet) router.register(r'web', views.WebViewSet, base_name='web') urlpatterns: Lista donde se definen los URL. N\u00f3tese que al incluir la variable router.urls, se incluyen autom\u00e1ticamente todas las URL asociadas a las vistas guardadas en la variable router. urlpatterns = [ url(r'^', include(router.urls)), url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework'))]","title":"urls.py"},{"location":"rest/urls/#modulo-rest-urls","text":"En este m\u00f3dulo se encuentran definidas las URL para el acceso al m\u00f3dulo REST. Para esto se utiliza el m\u00f3dulo routers del Django Rest Framework . Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770","title":"M\u00f3dulo: rest-urls"},{"location":"rest/urls/#router","text":"Variable donde se registran las vistas del m\u00f3dulo rest-views . Esta variable es un objeto DefaultRouter del Django Rest Framework . router = routers.DefaultRouter() router.register(r'tweets', views.TweetViewSet) router.register(r'stores', views.StoresViewSet) router.register(r'web', views.WebViewSet, base_name='web')","title":"router:"},{"location":"rest/urls/#urlpatterns","text":"Lista donde se definen los URL. N\u00f3tese que al incluir la variable router.urls, se incluyen autom\u00e1ticamente todas las URL asociadas a las vistas guardadas en la variable router. urlpatterns = [ url(r'^', include(router.urls)), url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework'))]","title":"urlpatterns:"},{"location":"rest/views/","text":"M\u00f3dulo: rest-views En este m\u00f3dulo se definen los controladores de las vistas de acceso al m\u00f3dulo REST utilizando el m\u00f3dulo viewsets del Django Rest Framework . Autores Version 1.0: Antonio Cipagauta, 05-38040 | Douglas Torres, 11-11027 Version 2.0: Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Funciones Auxiliares REST Tweets searchDataBase: Versi\u00f3n 1.0 Funci\u00f3n que verifica que la medicina buscada por el usuario se encuentra en la base de datos y busca las medicinas equivalentes. Recibe el nombre de la medicina y devuelve componente activo, lista de equivalentes y un booleano que representa la existencia de un error. def searchDataBase(medName) -> (Activo, QuerySet<Medicina>, bool) retrieveTweets: Versi\u00f3n 1.0 Funci\u00f3n que busca por cada Medicina en listaMedicinas los tweets asociados en la BD. Versi\u00f3n 2.0 Filtra por tweets no expirados y ordena por fecha en orden decreciente. Devuelve la lista de Tweets encontrados. def retrieveTweets(listaMedicinas) -> QuerySet<Tweet> buscaTweets: Versi\u00f3n 1.0 Funci\u00f3n que busca los tweets asociados a una medicina y todos sus equivalentes en la BD. Utiliza la funci\u00f3n searchDataBase para encontrar los equivalentes a la medicina ingresada. Utiliza la funci\u00f3n retrieveTweets para buscar los Tweets de la lista de medicinas obtenida por searchDataBase. Recibe el nombre de una medicina y devuelve la lista de Tweets. Versi\u00f3n 2.0 Funci\u00f3n reemplazada por buscaTwitter , que se basa en esta para buscar en la BD. def buscaTweets(medName) -> QuerySet<Tweet> buscaTwitter: Versi\u00f3n 2.0 Funci\u00f3n que busca los Tweets asociados a una medicina y todos sus equivalentes en la BD. Si consigue Tweets en la BD, revisa si el Tweet m\u00e1s reciente fue buscado hace menos tiempo que los minutos definidos en la variable del m\u00f3dulo de configuraci\u00f3n \"TWEET_UPDATE\" . Si fue buscado hace menos tiempo que dichos minutos, devuelve el query de la BD. En caso contrario, utiliza la funci\u00f3n threadingTweets del m\u00f3dulo classifier para buscar y clasificar Tweets a partir del id mas reciente de los Tweets en la BD. Si no consigue Tweets en la BD, realiza la b\u00fasqueda con la funci\u00f3n threadingTweets mencionada previamente. Recibe el nombre de una medicina, y devuelve una lista de Tweets y un booleano que define si se consigui\u00f3 la medicina. def buscaTwitter(medName) -> (QuerySet<Tweet>, bool) Funciones Auxiliares REST Stores getComponent: Versi\u00f3n 2.0 Funci\u00f3n que busca el componente activo de un medicamento dado. Recibe el nombre de la medicina y devuelve una lista con un objeto Activo. def getComponent(medName) -> QuerySet<Activo> retrieveInventory: Versi\u00f3n 2.0 Funci\u00f3n que busca el componente activo de un medicamento en los inventarios de las farmacias asociadas. Para conseguir el componente activo, utiliza la funci\u00f3n getComponent . Recibe el nombre de una medicina y devuelve una lista de los productos por tienda. def retrieveInventory(medName) -> QuerySet<ProductosPorTienda> Controladores de las Vistas Clase TweetViewSet: Versi\u00f3n 2.0 Clase que hereda de viewsets.ReadOnlyModelViewSet del m\u00f3dulo viewsets del Django Rest Framework. Define la tabla de la BD que mostrar\u00e1 y el serializador que convertira las filas de la tabla en JSON. La funci\u00f3n list() define la respuesta JSON a mostrar. Utiliza la funci\u00f3n buscaTwitter y el serializador TweetSerializer . class TweetViewSet(viewsets.ReadOnlyModelViewSet): queryset = Tweet.objects.all() serializer_class = TweetSerializer def list(self, request, pk=None): ... return Response(queryset) Clase StoresViewSet: Versi\u00f3n 2.0 Clase que hereda de viewsets.ReadOnlyModelViewSet del m\u00f3dulo viewsets del Django Rest Framework. Define la tabla de la BD que mostrar\u00e1 y el serializador que convertira las filas de la tabla en JSON. La funci\u00f3n list() define la respuesta JSON a mostrar. Utiliza la funci\u00f3n retrieveInventory y el serializador InventorySerializer . class StoresViewSet(viewsets.ReadOnlyModelViewSet): queryset = store.ProductosPorTienda.objects.all() serializer_class = storeSerializers.InventorySerializer def list(self, request, pk=None): ... return Response(queryset) Clase WebViewSet: Versi\u00f3n 2.0 Clase que hereda de viewsets.ViewSet del m\u00f3dulo viewsets del Django Rest Framework. No necesita definir una tabla en la BD ni un seralizador, porque las herramientas del m\u00f3dulo WebCrawler ya devuelven un objeto compatible con JSON. La funci\u00f3n list() realiza las b\u00fasquedas, las concatena y las devuelve en la respuesta. class WebViewSet(viewsets.ViewSet): def list(self, request): ... return Response(queryset)","title":"views.py"},{"location":"rest/views/#modulo-rest-views","text":"En este m\u00f3dulo se definen los controladores de las vistas de acceso al m\u00f3dulo REST utilizando el m\u00f3dulo viewsets del Django Rest Framework . Autores Version 1.0: Antonio Cipagauta, 05-38040 | Douglas Torres, 11-11027 Version 2.0: Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770","title":"M\u00f3dulo: rest-views"},{"location":"rest/views/#funciones-auxiliares-rest-tweets","text":"","title":"Funciones Auxiliares REST Tweets"},{"location":"rest/views/#searchdatabase","text":"Versi\u00f3n 1.0 Funci\u00f3n que verifica que la medicina buscada por el usuario se encuentra en la base de datos y busca las medicinas equivalentes. Recibe el nombre de la medicina y devuelve componente activo, lista de equivalentes y un booleano que representa la existencia de un error. def searchDataBase(medName) -> (Activo, QuerySet<Medicina>, bool)","title":"searchDataBase:"},{"location":"rest/views/#retrievetweets","text":"Versi\u00f3n 1.0 Funci\u00f3n que busca por cada Medicina en listaMedicinas los tweets asociados en la BD. Versi\u00f3n 2.0 Filtra por tweets no expirados y ordena por fecha en orden decreciente. Devuelve la lista de Tweets encontrados. def retrieveTweets(listaMedicinas) -> QuerySet<Tweet>","title":"retrieveTweets:"},{"location":"rest/views/#buscatweets","text":"Versi\u00f3n 1.0 Funci\u00f3n que busca los tweets asociados a una medicina y todos sus equivalentes en la BD. Utiliza la funci\u00f3n searchDataBase para encontrar los equivalentes a la medicina ingresada. Utiliza la funci\u00f3n retrieveTweets para buscar los Tweets de la lista de medicinas obtenida por searchDataBase. Recibe el nombre de una medicina y devuelve la lista de Tweets. Versi\u00f3n 2.0 Funci\u00f3n reemplazada por buscaTwitter , que se basa en esta para buscar en la BD. def buscaTweets(medName) -> QuerySet<Tweet>","title":"buscaTweets:"},{"location":"rest/views/#buscatwitter","text":"Versi\u00f3n 2.0 Funci\u00f3n que busca los Tweets asociados a una medicina y todos sus equivalentes en la BD. Si consigue Tweets en la BD, revisa si el Tweet m\u00e1s reciente fue buscado hace menos tiempo que los minutos definidos en la variable del m\u00f3dulo de configuraci\u00f3n \"TWEET_UPDATE\" . Si fue buscado hace menos tiempo que dichos minutos, devuelve el query de la BD. En caso contrario, utiliza la funci\u00f3n threadingTweets del m\u00f3dulo classifier para buscar y clasificar Tweets a partir del id mas reciente de los Tweets en la BD. Si no consigue Tweets en la BD, realiza la b\u00fasqueda con la funci\u00f3n threadingTweets mencionada previamente. Recibe el nombre de una medicina, y devuelve una lista de Tweets y un booleano que define si se consigui\u00f3 la medicina. def buscaTwitter(medName) -> (QuerySet<Tweet>, bool)","title":"buscaTwitter:"},{"location":"rest/views/#funciones-auxiliares-rest-stores","text":"","title":"Funciones Auxiliares REST Stores"},{"location":"rest/views/#getcomponent","text":"Versi\u00f3n 2.0 Funci\u00f3n que busca el componente activo de un medicamento dado. Recibe el nombre de la medicina y devuelve una lista con un objeto Activo. def getComponent(medName) -> QuerySet<Activo>","title":"getComponent:"},{"location":"rest/views/#retrieveinventory","text":"Versi\u00f3n 2.0 Funci\u00f3n que busca el componente activo de un medicamento en los inventarios de las farmacias asociadas. Para conseguir el componente activo, utiliza la funci\u00f3n getComponent . Recibe el nombre de una medicina y devuelve una lista de los productos por tienda. def retrieveInventory(medName) -> QuerySet<ProductosPorTienda>","title":"retrieveInventory:"},{"location":"rest/views/#controladores-de-las-vistas","text":"","title":"Controladores de las Vistas"},{"location":"rest/views/#clase-tweetviewset","text":"Versi\u00f3n 2.0 Clase que hereda de viewsets.ReadOnlyModelViewSet del m\u00f3dulo viewsets del Django Rest Framework. Define la tabla de la BD que mostrar\u00e1 y el serializador que convertira las filas de la tabla en JSON. La funci\u00f3n list() define la respuesta JSON a mostrar. Utiliza la funci\u00f3n buscaTwitter y el serializador TweetSerializer . class TweetViewSet(viewsets.ReadOnlyModelViewSet): queryset = Tweet.objects.all() serializer_class = TweetSerializer def list(self, request, pk=None): ... return Response(queryset)","title":"Clase TweetViewSet:"},{"location":"rest/views/#clase-storesviewset","text":"Versi\u00f3n 2.0 Clase que hereda de viewsets.ReadOnlyModelViewSet del m\u00f3dulo viewsets del Django Rest Framework. Define la tabla de la BD que mostrar\u00e1 y el serializador que convertira las filas de la tabla en JSON. La funci\u00f3n list() define la respuesta JSON a mostrar. Utiliza la funci\u00f3n retrieveInventory y el serializador InventorySerializer . class StoresViewSet(viewsets.ReadOnlyModelViewSet): queryset = store.ProductosPorTienda.objects.all() serializer_class = storeSerializers.InventorySerializer def list(self, request, pk=None): ... return Response(queryset)","title":"Clase StoresViewSet:"},{"location":"rest/views/#clase-webviewset","text":"Versi\u00f3n 2.0 Clase que hereda de viewsets.ViewSet del m\u00f3dulo viewsets del Django Rest Framework. No necesita definir una tabla en la BD ni un seralizador, porque las herramientas del m\u00f3dulo WebCrawler ya devuelven un objeto compatible con JSON. La funci\u00f3n list() realiza las b\u00fasquedas, las concatena y las devuelve en la respuesta. class WebViewSet(viewsets.ViewSet): def list(self, request): ... return Response(queryset)","title":"Clase WebViewSet:"},{"location":"stores/commands/","text":"M\u00f3dulo: stores-commands En este m\u00f3dulo, ubicado en stores/management/commands, se encuentran los comandos personalizados de Django para gestionar los datos de los inventarios de las farmacias adscritas. Estos comandos pueden ser programados para gestionar autom\u00e1ticamente el servidor. expireStoreInventory.py Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Comando que elimina los productos por tienda que han llegado a su fecha de vencimiento. La variable del m\u00f3dulo de configuraci\u00f3n \"STORE_EXPIRATION\" define cuantos d\u00edas tarda el inventario de una tienda en expirar. Uso: python manage.py expireStoreInventory","title":"management/commands"},{"location":"stores/commands/#modulo-stores-commands","text":"En este m\u00f3dulo, ubicado en stores/management/commands, se encuentran los comandos personalizados de Django para gestionar los datos de los inventarios de las farmacias adscritas. Estos comandos pueden ser programados para gestionar autom\u00e1ticamente el servidor.","title":"M\u00f3dulo: stores-commands"},{"location":"stores/commands/#expirestoreinventorypy","text":"Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Comando que elimina los productos por tienda que han llegado a su fecha de vencimiento. La variable del m\u00f3dulo de configuraci\u00f3n \"STORE_EXPIRATION\" define cuantos d\u00edas tarda el inventario de una tienda en expirar.","title":"expireStoreInventory.py"},{"location":"stores/commands/#uso","text":"python manage.py expireStoreInventory","title":"Uso:"},{"location":"stores/models/","text":"M\u00f3dulo: stores-models En este m\u00f3dulo se encuentra definida la estructura de la base de datos para los inventarios de farmacias adscritas en un modelo orientado a objetos utilizando el Django ORM original. Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Clase Activo: Guarda cada componente activo sin repeticiones. class Activo(models.Model): componente = models.TextField(verbose_name=('Componente activo'),unique=True) Clase Medicina: Guarda cada medicina asociada a un componente activo. class Medicina(models.Model): nombre = models.TextField(verbose_name=('Nombre de marca')) activo = models.ForeignKey(Activo, related_name='componente-activo+', null=True, on_delete=models.CASCADE) Clase Presentacion: Guarda la presentaci\u00f3n asociada a una medicina. class Presentacion(models.Model): presentacion = models.TextField(verbose_name=('Presentacion')) medicina = models.ForeignKey(Medicina, related_name='formato',null=True, on_delete=models.CASCADE) Clase ProductosPorTienda: Asocia cada presentaci\u00f3n de un producto con una tienda, su disponibilidad y su fecha de ingreso del dato. Esta tabla permite representar el inventario de cada tienda. class ProductosPorTienda(models.Model): producto = models.ForeignKey(Presentacion, related_name='med', null=True, on_delete=models.CASCADE) tienda = models.ForeignKey(User, related_name='tienda', null=True, on_delete=models.CASCADE) disponibilidad = models.IntegerField(verbose_name=('Disponibilidad')) fechaDeIngreso = models.DateTimeField(verbose_name=('Fecha de actualizacion'), auto_now_add=True, blank=True)","title":"models.py"},{"location":"stores/models/#modulo-stores-models","text":"En este m\u00f3dulo se encuentra definida la estructura de la base de datos para los inventarios de farmacias adscritas en un modelo orientado a objetos utilizando el Django ORM original. Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770","title":"M\u00f3dulo: stores-models"},{"location":"stores/models/#clase-activo","text":"Guarda cada componente activo sin repeticiones. class Activo(models.Model): componente = models.TextField(verbose_name=('Componente activo'),unique=True)","title":"Clase Activo:"},{"location":"stores/models/#clase-medicina","text":"Guarda cada medicina asociada a un componente activo. class Medicina(models.Model): nombre = models.TextField(verbose_name=('Nombre de marca')) activo = models.ForeignKey(Activo, related_name='componente-activo+', null=True, on_delete=models.CASCADE)","title":"Clase Medicina:"},{"location":"stores/models/#clase-presentacion","text":"Guarda la presentaci\u00f3n asociada a una medicina. class Presentacion(models.Model): presentacion = models.TextField(verbose_name=('Presentacion')) medicina = models.ForeignKey(Medicina, related_name='formato',null=True, on_delete=models.CASCADE)","title":"Clase Presentacion:"},{"location":"stores/models/#clase-productosportienda","text":"Asocia cada presentaci\u00f3n de un producto con una tienda, su disponibilidad y su fecha de ingreso del dato. Esta tabla permite representar el inventario de cada tienda. class ProductosPorTienda(models.Model): producto = models.ForeignKey(Presentacion, related_name='med', null=True, on_delete=models.CASCADE) tienda = models.ForeignKey(User, related_name='tienda', null=True, on_delete=models.CASCADE) disponibilidad = models.IntegerField(verbose_name=('Disponibilidad')) fechaDeIngreso = models.DateTimeField(verbose_name=('Fecha de actualizacion'), auto_now_add=True, blank=True)","title":"Clase ProductosPorTienda:"},{"location":"stores/serializers/","text":"M\u00f3dulo: stores-serializers En este m\u00f3dulo se encuentran definidos los serializadores para convertir los objetos de la BD de las farmacias adscritas en objetos JSON. Utiliza el m\u00f3dulo serializers del Django Rest Framework . Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Clase StoreSerializer: Define la estructura en JSON de una tienda ( usuario de Django ). Nota: La direcci\u00f3n de cada tienda esta guardada en la variable last_name del usuario. Ejemplo: {'nombre': User.first_name, 'direccion': User.last_name}. class StoreSerializer(serializers.ModelSerializer): nombre = serializers.SerializerMethodField() direccion = serializers.SerializerMethodField() class Meta: model = User fields = ('nombre','direccion') read_only_fields = ('nombre','direccion') def get_nombre(self, obj): return obj.first_name def get_direccion(self, obj): return obj.last_name Clase ActivoSerializer: Define la estructura en JSON de un componente activo. Ejemplo: {'componente': Activo.componente}. class ActivoSerializer(serializers.ModelSerializer): class Meta: model = Activo fields = ('componente',) read_only_fields = ('componente',) Clase MedicinaSerializer: Define la estructura en JSON de una medicina. Ejemplo: {'nombre': Medicina.nombre, 'activo': {'componente': Activo.componente}}. N\u00f3tese que Medicina.activo se serializa con el serializador ActivoSerializer . class MedicinaSerializer(serializers.ModelSerializer): activo = ActivoSerializer() class Meta: model = Medicina fields = ('nombre', 'activo') read_only_fields = ('nombre', 'activo') Clase PresentacionSerializer: Define la estructura en JSON de una presentaci\u00f3n de una medicina. Ejemplo: {'presentacion': Presentacion.presentacion, 'medicina': {'nombre': Medicina.nombre, 'activo': {'componente': Activo.componente}}}. N\u00f3tese que Presentacion.medicina se serializa con el serializador MedicinaSerializer . class PresentacionSerializer(serializers.ModelSerializer): medicina = MedicinaSerializer() class Meta: model = Presentacion fields = ('presentacion', 'medicina') read_only_fields = ('presentacion', 'medicina') Clase InventorySerializer: Define la estructura en JSON de un producto por tienda. Ejemplo: {'producto': {'presentacion': Presentacion.presentacion, 'medicina': {'nombre': Medicina.nombre, 'activo': {'componente': Activo.componente}}}, 'tienda': {'nombre': User.first_name, 'direccion': User.last_name}, 'disponibilidad': ProductosPorTienda.disponibilidad, 'fechaDeIngreso': ProductosPorTienda.fechaDeIngreso}. N\u00f3tese que ProductosPorTienda.producto se serializa con el serializador PresentacionSerializer y ProductosPorTienda.tienda se serializa con el serializador StoreSerializer . class InventorySerializer(serializers.ModelSerializer): producto = PresentacionSerializer() tienda = StoreSerializer() class Meta: model = ProductosPorTienda fields = ('producto', 'tienda', 'disponibilidad', 'fechaDeIngreso') read_only_fields = ('producto', 'tienda', 'disponibilidad', 'fechaDeIngreso')","title":"serializers.py"},{"location":"stores/serializers/#modulo-stores-serializers","text":"En este m\u00f3dulo se encuentran definidos los serializadores para convertir los objetos de la BD de las farmacias adscritas en objetos JSON. Utiliza el m\u00f3dulo serializers del Django Rest Framework . Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770","title":"M\u00f3dulo: stores-serializers"},{"location":"stores/serializers/#clase-storeserializer","text":"Define la estructura en JSON de una tienda ( usuario de Django ). Nota: La direcci\u00f3n de cada tienda esta guardada en la variable last_name del usuario. Ejemplo: {'nombre': User.first_name, 'direccion': User.last_name}. class StoreSerializer(serializers.ModelSerializer): nombre = serializers.SerializerMethodField() direccion = serializers.SerializerMethodField() class Meta: model = User fields = ('nombre','direccion') read_only_fields = ('nombre','direccion') def get_nombre(self, obj): return obj.first_name def get_direccion(self, obj): return obj.last_name","title":"Clase StoreSerializer:"},{"location":"stores/serializers/#clase-activoserializer","text":"Define la estructura en JSON de un componente activo. Ejemplo: {'componente': Activo.componente}. class ActivoSerializer(serializers.ModelSerializer): class Meta: model = Activo fields = ('componente',) read_only_fields = ('componente',)","title":"Clase ActivoSerializer:"},{"location":"stores/serializers/#clase-medicinaserializer","text":"Define la estructura en JSON de una medicina. Ejemplo: {'nombre': Medicina.nombre, 'activo': {'componente': Activo.componente}}. N\u00f3tese que Medicina.activo se serializa con el serializador ActivoSerializer . class MedicinaSerializer(serializers.ModelSerializer): activo = ActivoSerializer() class Meta: model = Medicina fields = ('nombre', 'activo') read_only_fields = ('nombre', 'activo')","title":"Clase MedicinaSerializer:"},{"location":"stores/serializers/#clase-presentacionserializer","text":"Define la estructura en JSON de una presentaci\u00f3n de una medicina. Ejemplo: {'presentacion': Presentacion.presentacion, 'medicina': {'nombre': Medicina.nombre, 'activo': {'componente': Activo.componente}}}. N\u00f3tese que Presentacion.medicina se serializa con el serializador MedicinaSerializer . class PresentacionSerializer(serializers.ModelSerializer): medicina = MedicinaSerializer() class Meta: model = Presentacion fields = ('presentacion', 'medicina') read_only_fields = ('presentacion', 'medicina')","title":"Clase PresentacionSerializer:"},{"location":"stores/serializers/#clase-inventoryserializer","text":"Define la estructura en JSON de un producto por tienda. Ejemplo: {'producto': {'presentacion': Presentacion.presentacion, 'medicina': {'nombre': Medicina.nombre, 'activo': {'componente': Activo.componente}}}, 'tienda': {'nombre': User.first_name, 'direccion': User.last_name}, 'disponibilidad': ProductosPorTienda.disponibilidad, 'fechaDeIngreso': ProductosPorTienda.fechaDeIngreso}. N\u00f3tese que ProductosPorTienda.producto se serializa con el serializador PresentacionSerializer y ProductosPorTienda.tienda se serializa con el serializador StoreSerializer . class InventorySerializer(serializers.ModelSerializer): producto = PresentacionSerializer() tienda = StoreSerializer() class Meta: model = ProductosPorTienda fields = ('producto', 'tienda', 'disponibilidad', 'fechaDeIngreso') read_only_fields = ('producto', 'tienda', 'disponibilidad', 'fechaDeIngreso')","title":"Clase InventorySerializer:"},{"location":"stores/templates/","text":"M\u00f3dulo: stores-templates En este m\u00f3dulo, se encuentran las vistas de la aplicaci\u00f3n web, as\u00ed como la vista p\u00fablica de b\u00fasqueda. Estas vistas se encuentran dentro de la carpeta stores/templates y son archivos HTML con variables renderizadas por los constroladores de stores-views . index.html Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n P\u00e1gina de acceso p\u00fablico donde se le permite al usuario realizar b\u00fasquedas de medicinas utilizando todos los servicios ofrecidos por el servidor REST . Utiliza homeSearch.js para realizar las b\u00fasquedas. Vista Previa: login.html Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n P\u00e1gina de acceso publico donde se le permite al usuario iniciar sesi\u00f3n al sistema interno de farmacias adscritas. Se encuentra dentro de la carpeta templates/registration Vista Previa: readFile.html Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n P\u00e1gina de acceso restringido a usarios de farmacias donde se le permite al usuario cargar un archivo CSV con el inventario de medicinas. El archivo CSV debe tener las siguientes columnas: activo | medicina | presentacion | disponibilidad. Utiliza readFile.js para leer el archivo. Vista Previa:","title":"templates"},{"location":"stores/templates/#modulo-stores-templates","text":"En este m\u00f3dulo, se encuentran las vistas de la aplicaci\u00f3n web, as\u00ed como la vista p\u00fablica de b\u00fasqueda. Estas vistas se encuentran dentro de la carpeta stores/templates y son archivos HTML con variables renderizadas por los constroladores de stores-views .","title":"M\u00f3dulo: stores-templates"},{"location":"stores/templates/#indexhtml","text":"Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n P\u00e1gina de acceso p\u00fablico donde se le permite al usuario realizar b\u00fasquedas de medicinas utilizando todos los servicios ofrecidos por el servidor REST . Utiliza homeSearch.js para realizar las b\u00fasquedas.","title":"index.html"},{"location":"stores/templates/#vista-previa","text":"","title":"Vista Previa:"},{"location":"stores/templates/#loginhtml","text":"Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n P\u00e1gina de acceso publico donde se le permite al usuario iniciar sesi\u00f3n al sistema interno de farmacias adscritas. Se encuentra dentro de la carpeta templates/registration","title":"login.html"},{"location":"stores/templates/#vista-previa_1","text":"","title":"Vista Previa:"},{"location":"stores/templates/#readfilehtml","text":"Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n P\u00e1gina de acceso restringido a usarios de farmacias donde se le permite al usuario cargar un archivo CSV con el inventario de medicinas. El archivo CSV debe tener las siguientes columnas: activo | medicina | presentacion | disponibilidad. Utiliza readFile.js para leer el archivo.","title":"readFile.html"},{"location":"stores/templates/#vista-previa_2","text":"","title":"Vista Previa:"},{"location":"stores/urls/","text":"M\u00f3dulo: stores-urls En este m\u00f3dulo se encuentran definidas las URL para el acceso al m\u00f3dulo de la aplicaci\u00f3n web. Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 urlpatterns: Lista donde se definen los URL. N\u00f3tese que se utiliza la vista de authViews para hacer el cierre de sesi\u00f3n, que redirige a index.html. urlpatterns = [ path('readFile', views.StoresView.as_view(), name='readFile'), path('login/', views.UserLoginView.as_view(), name='login'), path('logout/', authViews.LogoutView.as_view(template_name='index.html'), name='logout',), ]","title":"urls.py"},{"location":"stores/urls/#modulo-stores-urls","text":"En este m\u00f3dulo se encuentran definidas las URL para el acceso al m\u00f3dulo de la aplicaci\u00f3n web. Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770","title":"M\u00f3dulo: stores-urls"},{"location":"stores/urls/#urlpatterns","text":"Lista donde se definen los URL. N\u00f3tese que se utiliza la vista de authViews para hacer el cierre de sesi\u00f3n, que redirige a index.html. urlpatterns = [ path('readFile', views.StoresView.as_view(), name='readFile'), path('login/', views.UserLoginView.as_view(), name='login'), path('logout/', authViews.LogoutView.as_view(template_name='index.html'), name='logout',), ]","title":"urlpatterns:"},{"location":"stores/views/","text":"M\u00f3dulo: stores-views En este m\u00f3dulo se definen los controladores de las vistas para el m\u00f3dulo de la aplicaci\u00f3n web utilizando el m\u00f3dulo views de Django . Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Controladores para vistas de farmacias adscritas Clase LoginView: Clase que hereda de LoginView del m\u00f3dulo auth.views de Django. Define el formulario de Django a utilizar para renderizar en el archivo html correspondiente (templates/registration/login.html). En el archivo stores/forms.py se definen las caracter\u00edsticas que se esperan renderizar del formulario de inicio de sesi\u00f3n de la siguiente manera: class LoginForm(AuthenticationForm): username = forms.CharField(widget=forms.TextInput(attrs={'class':'form-control', 'id':'inputEmail', 'placeholder':'Nombre de usuario'})) password = forms.CharField(widget=forms.PasswordInput(attrs={'class':'form-control', 'id':'inputPassword', 'placeholder':'Contrase\u00f1a'})) Esto se asigna en la clase del controlador de la siguiente manera: class UserLoginView(LoginView): form_class = LoginForm Clase StoresView: Clase que hereda de TemplateView del m\u00f3dulo views.generic de Django. Define las acciones a realizar cuando se accede a la p\u00e1gina de lectura de archivo CSV del inventario para farmacias adscritas. La funci\u00f3n get se llama cuando se recibe una petici\u00f3n GET, en este caso, cuando no se env\u00eda un inventario. La funci\u00f3n post se llama cuando se recibe una petici\u00f3n POST, en este caso, cuando se env\u00eda un inventario. N\u00f3tese que cuando se accede por get, la variable success es renderizada con el valor -1, esto para que no se muestre ningun mensaje al usuario. Cuando se accede por post y el archivo es cargado con \u00e9xito, la variable success es renderizada con el valor 1, para mostrar un mensaje de carga exitosa. De la misma manera, si hay un error, se renderizar\u00e1 con valor 0 para mostrar un mensaje de error. class StoresView(TemplateView): def get(self, request): ... return render(request, 'readFile.html', {'success': -1}) def post(self, request): ... return render(request, 'readFile.html', {'success': 1}) Controlador de la vista p\u00fablica de b\u00fasqueda Clase HomeView: Clase que hereda de TemplateView del m\u00f3dulo views.generic de Django. Define las acciones a realizar cuando se accede a la p\u00e1gina de inicio y de b\u00fasqueda. Hasta ahora, todo el trabajo de la p\u00e1gina de inicio se encuentra del lado del cliente, puede conseguir m\u00e1s informaci\u00f3n en templates . class HomeView(TemplateView): def get(self, request): return render(request, 'index.html', {}) def post(self, request): return render(request, 'index.html', {})","title":"views.py"},{"location":"stores/views/#modulo-stores-views","text":"En este m\u00f3dulo se definen los controladores de las vistas para el m\u00f3dulo de la aplicaci\u00f3n web utilizando el m\u00f3dulo views de Django . Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770","title":"M\u00f3dulo: stores-views"},{"location":"stores/views/#controladores-para-vistas-de-farmacias-adscritas","text":"","title":"Controladores para vistas de farmacias adscritas"},{"location":"stores/views/#clase-loginview","text":"Clase que hereda de LoginView del m\u00f3dulo auth.views de Django. Define el formulario de Django a utilizar para renderizar en el archivo html correspondiente (templates/registration/login.html). En el archivo stores/forms.py se definen las caracter\u00edsticas que se esperan renderizar del formulario de inicio de sesi\u00f3n de la siguiente manera: class LoginForm(AuthenticationForm): username = forms.CharField(widget=forms.TextInput(attrs={'class':'form-control', 'id':'inputEmail', 'placeholder':'Nombre de usuario'})) password = forms.CharField(widget=forms.PasswordInput(attrs={'class':'form-control', 'id':'inputPassword', 'placeholder':'Contrase\u00f1a'})) Esto se asigna en la clase del controlador de la siguiente manera: class UserLoginView(LoginView): form_class = LoginForm","title":"Clase LoginView:"},{"location":"stores/views/#clase-storesview","text":"Clase que hereda de TemplateView del m\u00f3dulo views.generic de Django. Define las acciones a realizar cuando se accede a la p\u00e1gina de lectura de archivo CSV del inventario para farmacias adscritas. La funci\u00f3n get se llama cuando se recibe una petici\u00f3n GET, en este caso, cuando no se env\u00eda un inventario. La funci\u00f3n post se llama cuando se recibe una petici\u00f3n POST, en este caso, cuando se env\u00eda un inventario. N\u00f3tese que cuando se accede por get, la variable success es renderizada con el valor -1, esto para que no se muestre ningun mensaje al usuario. Cuando se accede por post y el archivo es cargado con \u00e9xito, la variable success es renderizada con el valor 1, para mostrar un mensaje de carga exitosa. De la misma manera, si hay un error, se renderizar\u00e1 con valor 0 para mostrar un mensaje de error. class StoresView(TemplateView): def get(self, request): ... return render(request, 'readFile.html', {'success': -1}) def post(self, request): ... return render(request, 'readFile.html', {'success': 1})","title":"Clase StoresView:"},{"location":"stores/views/#controlador-de-la-vista-publica-de-busqueda","text":"","title":"Controlador de la vista p\u00fablica de b\u00fasqueda"},{"location":"stores/views/#clase-homeview","text":"Clase que hereda de TemplateView del m\u00f3dulo views.generic de Django. Define las acciones a realizar cuando se accede a la p\u00e1gina de inicio y de b\u00fasqueda. Hasta ahora, todo el trabajo de la p\u00e1gina de inicio se encuentra del lado del cliente, puede conseguir m\u00e1s informaci\u00f3n en templates . class HomeView(TemplateView): def get(self, request): return render(request, 'index.html', {}) def post(self, request): return render(request, 'index.html', {})","title":"Clase HomeView:"},{"location":"stores/js/homeSearch/","text":"M\u00f3dulo: stores-homeSearch.js En este m\u00f3dulo se encuentran las funciones de JavaScript y jQuery que permiten hacer una b\u00fasqueda din\u00e1mica en la p\u00e1gina de inicio, llamando al servidor REST . Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 toggleTweets: Minimiza o restaura la caja donde se muestran los tweets conseguidos. function toggleTweets() -> HTML: esconde un div toggleWeb: Minimiza o restaura la caja donde se muestran los productos conseguidos en farmacias. function toggleWeb() -> HTML: esconde un div startSearch: Hace la b\u00fasqueda a partir del valor escrito en #searchBox y llama a las funciones que, con Ajax , buscan y muestran los resultados. function startSearch() -> HTML: muestra div de resultados y llama funciones asincronas de busqueda ajaxBuscamedTweets: Funci\u00f3n que recibe el nombre de una medicina y utiliza el m\u00f3dulo ajax de jQuery para hacer un llamado al controlador de b\u00fasqueda en Twitter del servidor REST. Con el resultado, llama a la funci\u00f3n ajaxTwitter para incrustar el tweet con el formato de Twittter . function ajaxBuscamedTweets(med) -> None ajaxTwitter: Funci\u00f3n que recibe el url de un tweet, y utiliza el m\u00f3dulo ajax de jQuery para hacer un llamado al servidor REST de publish.twitter.com y obtener el c\u00f3digo html para incrustar el tweet en la caja de tweets. function ajaxTwitter(tweetUrl) -> HTML: inserta resultado en div de tweets ajaxBuscamedWeb: Funci\u00f3n que recibe el nombre de una medicina y utiliza el m\u00f3dulo ajax de jQuery para hacer un llamado al controlador de b\u00fasqueda en web del servidor REST. Con el resultado, llama a la funci\u00f3n htmlForWeb para obtener el formato en HTML predeterminado e incrustar el resultado. function ajaxBuscamedWeb(med) -> HTML: inserta resultado en div de farmacias htmlForWeb: Funci\u00f3n que recibe el objeto obtenido por ajaxBuscamedWeb , y renderiza el objeto en un formato HTML predeterminado que puede ser incrustado en la p\u00e1gina. function htmlForWeb(store) -> String: formato HTML ajaxBuscamedStores: Funci\u00f3n que recibe el nombre de una medicina y utiliza el m\u00f3dulo ajax de jQuery para hacer un llamado al controlador de b\u00fasqueda en farmacias adscritas del servidor REST. Con el resultado, llama a la funci\u00f3n htmlForStores para obtener el formato en HTML predeterminado e incrustar el resultado. function ajaxBuscamedStores(med) -> HTML: inserta resultado en div de farmacias htmlForStores: Funci\u00f3n que recibe el objeto obtenido por ajaxBuscamedStores , y renderiza el objeto en un formato HTML predeterminado que puede ser incrustado en la p\u00e1gina. function htmlForStores(store) -> String: formato HTML","title":"homeSearch"},{"location":"stores/js/homeSearch/#modulo-stores-homesearchjs","text":"En este m\u00f3dulo se encuentran las funciones de JavaScript y jQuery que permiten hacer una b\u00fasqueda din\u00e1mica en la p\u00e1gina de inicio, llamando al servidor REST . Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770","title":"M\u00f3dulo: stores-homeSearch.js"},{"location":"stores/js/homeSearch/#toggletweets","text":"Minimiza o restaura la caja donde se muestran los tweets conseguidos. function toggleTweets() -> HTML: esconde un div","title":"toggleTweets:"},{"location":"stores/js/homeSearch/#toggleweb","text":"Minimiza o restaura la caja donde se muestran los productos conseguidos en farmacias. function toggleWeb() -> HTML: esconde un div","title":"toggleWeb:"},{"location":"stores/js/homeSearch/#startsearch","text":"Hace la b\u00fasqueda a partir del valor escrito en #searchBox y llama a las funciones que, con Ajax , buscan y muestran los resultados. function startSearch() -> HTML: muestra div de resultados y llama funciones asincronas de busqueda","title":"startSearch:"},{"location":"stores/js/homeSearch/#ajaxbuscamedtweets","text":"Funci\u00f3n que recibe el nombre de una medicina y utiliza el m\u00f3dulo ajax de jQuery para hacer un llamado al controlador de b\u00fasqueda en Twitter del servidor REST. Con el resultado, llama a la funci\u00f3n ajaxTwitter para incrustar el tweet con el formato de Twittter . function ajaxBuscamedTweets(med) -> None","title":"ajaxBuscamedTweets:"},{"location":"stores/js/homeSearch/#ajaxtwitter","text":"Funci\u00f3n que recibe el url de un tweet, y utiliza el m\u00f3dulo ajax de jQuery para hacer un llamado al servidor REST de publish.twitter.com y obtener el c\u00f3digo html para incrustar el tweet en la caja de tweets. function ajaxTwitter(tweetUrl) -> HTML: inserta resultado en div de tweets","title":"ajaxTwitter:"},{"location":"stores/js/homeSearch/#ajaxbuscamedweb","text":"Funci\u00f3n que recibe el nombre de una medicina y utiliza el m\u00f3dulo ajax de jQuery para hacer un llamado al controlador de b\u00fasqueda en web del servidor REST. Con el resultado, llama a la funci\u00f3n htmlForWeb para obtener el formato en HTML predeterminado e incrustar el resultado. function ajaxBuscamedWeb(med) -> HTML: inserta resultado en div de farmacias","title":"ajaxBuscamedWeb:"},{"location":"stores/js/homeSearch/#htmlforweb","text":"Funci\u00f3n que recibe el objeto obtenido por ajaxBuscamedWeb , y renderiza el objeto en un formato HTML predeterminado que puede ser incrustado en la p\u00e1gina. function htmlForWeb(store) -> String: formato HTML","title":"htmlForWeb:"},{"location":"stores/js/homeSearch/#ajaxbuscamedstores","text":"Funci\u00f3n que recibe el nombre de una medicina y utiliza el m\u00f3dulo ajax de jQuery para hacer un llamado al controlador de b\u00fasqueda en farmacias adscritas del servidor REST. Con el resultado, llama a la funci\u00f3n htmlForStores para obtener el formato en HTML predeterminado e incrustar el resultado. function ajaxBuscamedStores(med) -> HTML: inserta resultado en div de farmacias","title":"ajaxBuscamedStores:"},{"location":"stores/js/homeSearch/#htmlforstores","text":"Funci\u00f3n que recibe el objeto obtenido por ajaxBuscamedStores , y renderiza el objeto en un formato HTML predeterminado que puede ser incrustado en la p\u00e1gina. function htmlForStores(store) -> String: formato HTML","title":"htmlForStores:"},{"location":"stores/js/readFile/","text":"M\u00f3dulo: stores-readFile.js En este m\u00f3dulo se encuentran las funciones de JavaScript y jQuery que permiten leer un archivo CSV y enviarlo por POST al controlador del m\u00f3dulo stores que permite agregar un inventario a la BD. Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 checkData: Funci\u00f3n que recibe datos de un archivo CSV y revisa que tenga las columnas: activo | medicina | presentacion | disponibilidad . function checkData(data) -> bool readCSV: Funci\u00f3n que obtiene el valor del archivo escrito en #fileName , revisa que sea CSV, lee el archivo con el m\u00f3dulo FileReader de JavaScript, convierte a objeto JSON con el m\u00f3dulo csv.toObjects de jQuery.CSV , revisa las columnas con checkData y env\u00eda el objeto en forma de String al controlador del m\u00f3dulo stores a trav\u00e9s de una petici\u00f3n POST. function readCSV() -> HTML: asigna variable \"#csv\" y envia formulario \"#Login\"","title":"readFile"},{"location":"stores/js/readFile/#modulo-stores-readfilejs","text":"En este m\u00f3dulo se encuentran las funciones de JavaScript y jQuery que permiten leer un archivo CSV y enviarlo por POST al controlador del m\u00f3dulo stores que permite agregar un inventario a la BD. Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770","title":"M\u00f3dulo: stores-readFile.js"},{"location":"stores/js/readFile/#checkdata","text":"Funci\u00f3n que recibe datos de un archivo CSV y revisa que tenga las columnas: activo | medicina | presentacion | disponibilidad . function checkData(data) -> bool","title":"checkData:"},{"location":"stores/js/readFile/#readcsv","text":"Funci\u00f3n que obtiene el valor del archivo escrito en #fileName , revisa que sea CSV, lee el archivo con el m\u00f3dulo FileReader de JavaScript, convierte a objeto JSON con el m\u00f3dulo csv.toObjects de jQuery.CSV , revisa las columnas con checkData y env\u00eda el objeto en forma de String al controlador del m\u00f3dulo stores a trav\u00e9s de una petici\u00f3n POST. function readCSV() -> HTML: asigna variable \"#csv\" y envia formulario \"#Login\"","title":"readCSV:"},{"location":"webcrawler/webcrawler/","text":"M\u00f3dulo: webcrawler En este m\u00f3dulo se encuentran los webcrawlers que buscan la informaci\u00f3n de inventario directamente en las p\u00e1ginas web de diferentes farmacias. Utilizan el m\u00f3dulo requests para hacer las peticiones a las p\u00e1ginas y BeautifulSoup para analizar las respuestas HTML en Python. webCrawlerFarmarket.py Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Archivo donde se encuentran las funciones que permiten las b\u00fasquedas en la p\u00e1gina de Farmarket . Contiene un Main para realizar pruebas directamente. webCrawler: Funci\u00f3n que hace una petici\u00f3n POST (con timeout=30seg) a la p\u00e1gina de Farmarket con la variable 'txtProducto' asignada al valor de la medicina. Luego, la respuesta es analizada por BeautifulSoup y la informaci\u00f3n de los productos es recolectada por la funci\u00f3n collectInfo . def webCrawler(medicine): -> List<ProductosPorTienda> collectInfo: Recibe una lista de los tds (table data) del HTML, obtenida por BeautifulSoup , y de forma personalizada a la estructura de la p\u00e1gina de Farmarket , recolecta la informaci\u00f3n de los productos por tienda en una lista. def collectInfo(tds): -> List<ProductosPorTienda> webCrawlerFullFarmacia.py Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Archivo donde se encuentran las funciones que permiten las b\u00fasquedas en la p\u00e1gina de FullFarmacia . Contiene un Main para realizar pruebas directamente. webCrawler: Funci\u00f3n que hace una petici\u00f3n GET (con timeout=30seg) a la p\u00e1gina de FullFarmacia con la variable 'searchBox' asignada al valor de la medicina. Luego, la respuesta es analizada por BeautifulSoup y la informaci\u00f3n de los productos es recolectada por la funci\u00f3n collectInfo . def webCrawler(medicine): -> List<ProductosPorTienda> collectInfo: Recibe una lista de los tds (table data) dentro de 'productContainer' del HTML, obtenida por BeautifulSoup , y de forma personalizada a la estructura de la p\u00e1gina de FullFarmacia , recolecta la informaci\u00f3n de los productos por tienda en una lista. def collectInfo(tds): -> List<ProductosPorTienda> webCrawlerFundafarmacia.py Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Archivo donde se encuentran las funciones que permiten las b\u00fasquedas en la p\u00e1gina de Fundafarmacia . Contiene un Main para realizar pruebas directamente. webCrawler: Funci\u00f3n que hace una petici\u00f3n POST (con timeout=30seg) a la p\u00e1gina de Fundafarmacia con la variable 'producto' asignada al valor de la medicina. Luego, la respuesta es analizada por BeautifulSoup y la informaci\u00f3n de los productos es recolectada por la funci\u00f3n collectInfo . def webCrawler(medicine): -> List<ProductosPorTienda> collectInfo: Recibe una lista de los tds (table data) del HTML, obtenida por BeautifulSoup , y de forma personalizada a la estructura de la p\u00e1gina de Fundafarmacia , recolecta la informaci\u00f3n de los productos por tienda en una lista. def collectInfo(tds): -> List<ProductosPorTienda>","title":"Webcrawler"},{"location":"webcrawler/webcrawler/#modulo-webcrawler","text":"En este m\u00f3dulo se encuentran los webcrawlers que buscan la informaci\u00f3n de inventario directamente en las p\u00e1ginas web de diferentes farmacias. Utilizan el m\u00f3dulo requests para hacer las peticiones a las p\u00e1ginas y BeautifulSoup para analizar las respuestas HTML en Python.","title":"M\u00f3dulo: webcrawler"},{"location":"webcrawler/webcrawler/#webcrawlerfarmarketpy","text":"Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Archivo donde se encuentran las funciones que permiten las b\u00fasquedas en la p\u00e1gina de Farmarket . Contiene un Main para realizar pruebas directamente.","title":"webCrawlerFarmarket.py"},{"location":"webcrawler/webcrawler/#webcrawler","text":"Funci\u00f3n que hace una petici\u00f3n POST (con timeout=30seg) a la p\u00e1gina de Farmarket con la variable 'txtProducto' asignada al valor de la medicina. Luego, la respuesta es analizada por BeautifulSoup y la informaci\u00f3n de los productos es recolectada por la funci\u00f3n collectInfo . def webCrawler(medicine): -> List<ProductosPorTienda>","title":"webCrawler:"},{"location":"webcrawler/webcrawler/#collectinfo","text":"Recibe una lista de los tds (table data) del HTML, obtenida por BeautifulSoup , y de forma personalizada a la estructura de la p\u00e1gina de Farmarket , recolecta la informaci\u00f3n de los productos por tienda en una lista. def collectInfo(tds): -> List<ProductosPorTienda>","title":"collectInfo:"},{"location":"webcrawler/webcrawler/#webcrawlerfullfarmaciapy","text":"Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Archivo donde se encuentran las funciones que permiten las b\u00fasquedas en la p\u00e1gina de FullFarmacia . Contiene un Main para realizar pruebas directamente.","title":"webCrawlerFullFarmacia.py"},{"location":"webcrawler/webcrawler/#webcrawler_1","text":"Funci\u00f3n que hace una petici\u00f3n GET (con timeout=30seg) a la p\u00e1gina de FullFarmacia con la variable 'searchBox' asignada al valor de la medicina. Luego, la respuesta es analizada por BeautifulSoup y la informaci\u00f3n de los productos es recolectada por la funci\u00f3n collectInfo . def webCrawler(medicine): -> List<ProductosPorTienda>","title":"webCrawler:"},{"location":"webcrawler/webcrawler/#collectinfo_1","text":"Recibe una lista de los tds (table data) dentro de 'productContainer' del HTML, obtenida por BeautifulSoup , y de forma personalizada a la estructura de la p\u00e1gina de FullFarmacia , recolecta la informaci\u00f3n de los productos por tienda en una lista. def collectInfo(tds): -> List<ProductosPorTienda>","title":"collectInfo:"},{"location":"webcrawler/webcrawler/#webcrawlerfundafarmaciapy","text":"Autores Lautaro Villal\u00f3n, 12-10427 | Yarima Luciani, 13-10770 Descripci\u00f3n Archivo donde se encuentran las funciones que permiten las b\u00fasquedas en la p\u00e1gina de Fundafarmacia . Contiene un Main para realizar pruebas directamente.","title":"webCrawlerFundafarmacia.py"},{"location":"webcrawler/webcrawler/#webcrawler_2","text":"Funci\u00f3n que hace una petici\u00f3n POST (con timeout=30seg) a la p\u00e1gina de Fundafarmacia con la variable 'producto' asignada al valor de la medicina. Luego, la respuesta es analizada por BeautifulSoup y la informaci\u00f3n de los productos es recolectada por la funci\u00f3n collectInfo . def webCrawler(medicine): -> List<ProductosPorTienda>","title":"webCrawler:"},{"location":"webcrawler/webcrawler/#collectinfo_2","text":"Recibe una lista de los tds (table data) del HTML, obtenida por BeautifulSoup , y de forma personalizada a la estructura de la p\u00e1gina de Fundafarmacia , recolecta la informaci\u00f3n de los productos por tienda en una lista. def collectInfo(tds): -> List<ProductosPorTienda>","title":"collectInfo:"}]}